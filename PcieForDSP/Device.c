/*++

Module Name:

    device.c - Device handling events for example driver.

Abstract:

   This file contains the device entry points and callbacks.
    
Environment:

    Kernel-mode Driver Framework

--*/

#include "driver.h"
#include "device.tmh"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, PcieForDSPCreateDevice)
#endif

//
//NTSTATUS
//PcieForDSPCreateDevice(
//    _Inout_ PWDFDEVICE_INIT DeviceInit
//    )
///*++
//
//Routine Description:
//
//    Worker routine called to create a device and its software resources.
//
//Arguments:
//
//    DeviceInit - Pointer to an opaque init structure. Memory for this
//                    structure will be freed by the framework when the WdfDeviceCreate
//                    succeeds. So don't access the structure after that point.
//
//Return Value:
//
//    NTSTATUS
//
//--*/
//{
//    WDF_OBJECT_ATTRIBUTES         deviceAttributes;
//    PDEVICE_CONTEXT               deviceContext;
//    WDFDEVICE                     device;
//    NTSTATUS                      status;
//	WDF_PNPPOWER_EVENT_CALLBACKS  pnpPowerCallbacks;
//
//    PAGED_CODE();
//
//	
//
//
//    WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&deviceAttributes, DEVICE_CONTEXT);
//
//    status = WdfDeviceCreate(&DeviceInit, &deviceAttributes, &device);
//
//    if (NT_SUCCESS(status)) {
//        //
//        // Get a pointer to the device context structure that we just associated
//        // with the device object. We define this structure in the device.h
//        // header file. DeviceGetContext is an inline function generated by
//        // using the WDF_DECLARE_CONTEXT_TYPE_WITH_NAME macro in device.h.
//        // This function will do the type checking and return the device context.
//        // If you pass a wrong object handle it will return NULL and assert if
//        // run under framework verifier mode.
//        //
//        deviceContext = DeviceGetContext(device);
//
//        //
//        // Initialize the context.
//        //
//        deviceContext->PrivateDeviceData = 0;
//
//        //
//        // Create a device interface so that applications can find and talk
//        // to us.
//        //
//        status = WdfDeviceCreateDeviceInterface(
//            device,
//            &GUID_DEVINTERFACE_PcieForDSP,
//            NULL // ReferenceString
//            );
//
//        if (NT_SUCCESS(status)) {
//            //
//            // Initialize the I/O Package and any Queues
//            //
//            status = PcieForDSPQueueInitialize(device);
//        }
//    }
//
//    return status;
//}

NTSTATUS
PcieForDSPEvtDeviceAdd(
_In_    WDFDRIVER       Driver,
_Inout_ PWDFDEVICE_INIT DeviceInit
)
/*++
Routine Description:

EvtDeviceAdd is called by the framework in response to AddDevice
call from the PnP manager. We create and initialize a device object to
represent a new instance of the device.

Arguments:

Driver - Handle to a framework driver object created in DriverEntry

DeviceInit - Pointer to a framework-allocated WDFDEVICE_INIT structure.

Return Value:

NTSTATUS

--*/
{
	NTSTATUS                      status;
	WDF_OBJECT_ATTRIBUTES         attributes;
	PDEVICE_CONTEXT               pDevContext;
	WDFDEVICE                     device;
	WDF_PNPPOWER_EVENT_CALLBACKS  pnpPowerCallbacks;

	UNREFERENCED_PARAMETER(Driver);

	PAGED_CODE();// zhu  PAGED_CODE表示该代码占用分页内存，如果不说明，则占用系统的非分页内存

	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Entry");

	// 读、写请求的缓冲方式
	// 默认为Buffered方式，另外两种方式是Direct和Neither。
	WdfDeviceInitSetIoType(DeviceInit, WdfDeviceIoBuffered);

	// 注册PNP与Power回调函数

	// zhu
	// Zero out the PnpPowerCallbacks structure.
	WDF_PNPPOWER_EVENT_CALLBACKS_INIT(&pnpPowerCallbacks);

	// zhu
	// Set Callbacks for any of the functions we are interested in.
	// If no callback is set, Framework will take the default action
	// by itself.
	pnpPowerCallbacks.EvtDevicePrepareHardware = PcieForDspPreparaHardware;
	pnpPowerCallbacks.EvtDeviceReleaseHardware = PcieForDspReleaseHardware;

	//
	// These two callbacks set up and tear down hardware state that must be
	// done every time the device moves in and out of the D0-working state.
	//
	pnpPowerCallbacks.EvtDeviceD0Entry = PcieForDspDeviceD0Entry;  // hu 进入和退出D0状态时候的回调函数
	pnpPowerCallbacks.EvtDeviceD0Exit = PcieForDspDeviceD0Exit;   // hu 在此状态下，计算机在全功耗和全功能下运行

	// zhu
	// Register the PnP Callbacks..
	WdfDeviceInitSetPnpPowerEventCallbacks(DeviceInit, &pnpPowerCallbacks);

	// zhu
	// 设定设备环境块长度
	// 宏内部会调用sizeof(DEVICE_CONTEXT)求结构体长度
	// Initialize Fdo Attributes.
	// hu 分配一个DEVICE_CONTEXT的内存块，并且将内存块的指针保存到WDF_OBJECT_ATTRIBUTES里面
	WDF_OBJECT_ATTRIBUTES_INIT_CONTEXT_TYPE(&attributes, DEVICE_CONTEXT);

	// zhu
	// By opting for SynchronizationScopeDevice, we tell the framework to
	// synchronize callbacks events of all the objects directly associated
	// with the device. In this driver, we will associate queues and
	// and DpcForIsr. By doing that we don't have to worrry about synchronizing
	// access to device-context by Io Events and DpcForIsr because they would
	// not concurrently ever. Framework will serialize them by using an
	// internal device-lock.
	attributes.SynchronizationScope = WdfSynchronizationScopeDevice;

	// zhu
	// 创建WDF设备
	status = WdfDeviceCreate(&DeviceInit, &attributes, &device);
	if (!NT_SUCCESS(status))
	{
		TraceEvents(TRACE_LEVEL_ERROR, TRACE_DRIVER,"WdfDeviceCreate failed %!STATUS!", status);
		return status;
	}
	//status = PcieForDSPCreateDevice(DeviceInit);

	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Exit");

	return status;
}

VOID
PcieForDSPEvtDriverContextCleanup(
_In_ WDFOBJECT DriverObject
)
/*++
Routine Description:

Free all the resources allocated in DriverEntry.

Arguments:

DriverObject - handle to a WDF Driver object.

Return Value:

VOID.

--*/
{
	UNREFERENCED_PARAMETER(DriverObject);

	PAGED_CODE();

	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "%!FUNC! Entry");

	//
	// Stop WPP Tracing
	//
	WPP_CLEANUP(WdfDriverWdmGetDriverObject(DriverObject));

}


/*
 *  程序描述：
 *  在启动设备需要初始化时运行，建立一个DMA通道和任一I/O端口。该函数只在设备启动或重启时调用。
 *
 *  参数：
 *  Device - 指向WDFDEVICE的句柄
 *  Resources - 与设备相关联的PNP resources，对于PCI设备，大部分时间无效
 *  ResourcesTranslated - 与设备相关联的translated PnP resources，对于PCI设备很重要
 *
 *  返回值：
 *  NT status code - failure will result in the device stack being torn down
 */
NTSTATUS
PcieForDspPreparaHardware(
WDFDEVICE     Device,
WDFCMRESLIST  Resources,
WDFCMRESLIST  ResourcesTranslated
)
{

}


/*
 *  程序描述：
 *  取消PcieForDspPreparaHardware中的映射。在设备因resource rebalance,surprise-removed or query-removed被停止时调用
 *
 *  参数：
 *  Device - 指向WDFDEVICE的句柄
 *  ResourcesTranslated - 与设备相关联的translated PnP resources，对于PCI设备很重要
 *
 *  返回值：
 *  NT status code - failure will result in the device stack being torn down
 */
NTSTATUS
PcieForDspReleaseHardware(
WDFDEVICE     Device,
WDFCMRESLIST  ResourcesTranslated
)
{

}

/*
*  程序描述：
*  取消PcieForDspPreparaHardware中的映射。在设备因resource rebalance,surprise-removed or query-removed被停止时调用
*
*  参数：
*  Device - 指向WDFDEVICE的句柄
*  ResourcesTranslated - 与设备相关联的translated PnP resources，对于PCI设备很重要
*
*  返回值：
*  NT status code - failure will result in the device stack being torn down
*/
NTSTATUS
PcieForDspDeviceD0Entry(
_In_  WDFDEVICE Device,
_In_  WDF_POWER_DEVICE_STATE PreviousState
)
{
	NTSTATUS  status = STATUS_SUCCESS;

	UNREFERENCED_PARAMETER(Device);
	UNREFERENCED_PARAMETER(PreviousState);

	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "--> %!FUNC!");


	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "<-- %!FUNC!");
	return status;
}

/*
*  程序描述：
*  取消PcieForDspPreparaHardware中的映射。在设备因resource rebalance,surprise-removed or query-removed被停止时调用
*
*  参数：
*  Device - 指向WDFDEVICE的句柄
*  ResourcesTranslated - 与设备相关联的translated PnP resources，对于PCI设备很重要
*
*  返回值：
*  NT status code - failure will result in the device stack being torn down
*/
NTSTATUS
PcieForDspDeviceD0Exit(
_In_  WDFDEVICE Device,
_In_  WDF_POWER_DEVICE_STATE TargetState
)
{
	NTSTATUS  status = STATUS_SUCCESS;
	PDEVICE_CONTEXT   devExt;

	PAGED_CODE();

	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "--> %!FUNC!");

	devExt = PcieGetDeviceContext(Device);

	switch (TargetState) {
	case WdfPowerDeviceD1:
	case WdfPowerDeviceD2:
	case WdfPowerDeviceD3:

		//
		// Fill in any code to save hardware state here.
		//

		//
		// Fill in any code to put the device in a low-power state here.
		//
		break;

	case WdfPowerDevicePrepareForHibernation:

		//
		// Fill in any code to save hardware state here.  Do not put in any
		// code to shut the device off.  If this device cannot support being
		// in the paging path (or being a parent or grandparent of a paging
		// path device) then this whole case can be deleted.
		//

		break;

	case WdfPowerDeviceD3Final:
	default:
		//
		// Reset the hardware, as we're shutting down for the last time.
		//
		if (devExt->MemBarBase){
			PcieDeviceResetDMA(devExt->MemBarBase);
		}
		break;
	}

	TraceEvents(TRACE_LEVEL_INFORMATION, TRACE_DRIVER, "<-- %!FUNC!");

	return status;
}